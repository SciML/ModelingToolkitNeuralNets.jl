<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Friction Model · ModelingToolkitNeuralNets.jl</title><meta name="title" content="Friction Model · ModelingToolkitNeuralNets.jl"/><meta property="og:title" content="Friction Model · ModelingToolkitNeuralNets.jl"/><meta property="twitter:title" content="Friction Model · ModelingToolkitNeuralNets.jl"/><meta name="description" content="Documentation for ModelingToolkitNeuralNets.jl."/><meta property="og:description" content="Documentation for ModelingToolkitNeuralNets.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkitNeuralNets.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitNeuralNets.jl/stable/friction/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitNeuralNets.jl/stable/friction/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitNeuralNets.jl/stable/friction/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ModelingToolkitNeuralNets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ModelingToolkitNeuralNets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Friction Model</a><ul class="internal"><li><a class="tocitem" href="#Julia-Environment"><span>Julia Environment</span></a></li><li><a class="tocitem" href="#Problem-Setup"><span>Problem Setup</span></a></li><li><a class="tocitem" href="#Model-Setup"><span>Model Setup</span></a></li><li><a class="tocitem" href="#Optimization-Setup"><span>Optimization Setup</span></a></li><li><a class="tocitem" href="#Visualization-of-results"><span>Visualization of results</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Friction Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Friction Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitNeuralNets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitNeuralNets.jl/blob/main/docs/src/friction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling-Non-Linear-Friction-Model-using-UDEs"><a class="docs-heading-anchor" href="#Modeling-Non-Linear-Friction-Model-using-UDEs">Modeling Non Linear Friction Model using UDEs</a><a id="Modeling-Non-Linear-Friction-Model-using-UDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-Non-Linear-Friction-Model-using-UDEs" title="Permalink"></a></h1><p>Friction between moving bodies is not trivial to model. There have been idealised linear models which are not always useful in complicated systems. There have been many theories and non linear models which we can use, but they are not perfect. The aim of this tutorial to use Universal Differential Equations to showcase how we can embed a neural network to learn an unknown non linear friction model.</p><h2 id="Julia-Environment"><a class="docs-heading-anchor" href="#Julia-Environment">Julia Environment</a><a id="Julia-Environment-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Environment" title="Permalink"></a></h2><p>First, lets import the required packages.</p><pre><code class="language-julia hljs">using ModelingToolkitNeuralNets
using ModelingToolkit
import ModelingToolkit.t_nounits as t
import ModelingToolkit.D_nounits as Dt
using ModelingToolkitStandardLibrary.Blocks
using OrdinaryDiffEq
using Optimization
using OptimizationOptimisers: Adam
using SciMLStructures
using SciMLStructures: Tunable
using SymbolicIndexingInterface
using StableRNGs
using Lux
using Plots</code></pre><h2 id="Problem-Setup"><a class="docs-heading-anchor" href="#Problem-Setup">Problem Setup</a><a id="Problem-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Setup" title="Permalink"></a></h2><p>Let&#39;s use the friction model presented in https://www.mathworks.com/help/simscape/ref/translationalfriction.html for generating data.</p><pre><code class="language-julia hljs">Fbrk = 100.0
vbrk = 10.0
Fc = 80.0
vst = vbrk / 10
vcol = vbrk * sqrt(2)
function friction(v)
    sqrt(2 * MathConstants.e) * (Fbrk - Fc) * exp(-(v / vst)^2) * (v / vst) +
    Fc * tanh(v / vcol)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">friction (generic function with 1 method)</code></pre><p>Next, we define the model - an object sliding in 1D plane with a constant force <code>Fu</code> acting on it and friction force opposing the motion.</p><pre><code class="language-julia hljs">function friction_true()
    @variables y(t) = 0.0
    @constants Fu = 120.0
    eqs = [
        Dt(y) ~ Fu - friction(y)
    ]
    return ODESystem(eqs, t, name = :friction_true)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">friction_true (generic function with 1 method)</code></pre><p>Now that we have defined the model, we will simulate it from 0 to 0.1 seconds.</p><pre><code class="language-julia hljs">model_true = structural_simplify(friction_true())
prob_true = ODEProblem(model_true, [], (0, 0.1), [])
sol_ref = solve(prob_true, Rodas4(); saveat = 0.001)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 1st order linear
t: 101-element Vector{Float64}:
 0.0
 0.001
 0.002
 0.003
 0.004
 0.005
 0.006
 0.007
 0.008
 0.009
 ⋮
 0.092
 0.093
 0.094
 0.095
 0.096
 0.097
 0.098
 0.099
 0.1
u: 101-element Vector{Vector{Float64}}:
 [0.0]
 [0.1169352563438387]
 [0.22815063944912414]
 [0.3344560537928513]
 [0.43680383317283106]
 [0.5361810711752443]
 [0.6335357754030169]
 [0.7297484315732473]
 [0.8255832780189796]
 [0.9216604041738702]
 ⋮
 [8.586443837792629]
 [8.662919111628263]
 [8.739090192373276]
 [8.81496014793011]
 [8.89053204620121]
 [8.965808955089015]
 [9.040793942495968]
 [9.115490076324512]
 [9.189900424477088]</code></pre><p>Let&#39;s plot it.</p><pre><code class="language-julia hljs">scatter(sol_ref, label = &quot;velocity&quot;)</code></pre><img src="5cd6f176.svg" alt="Example block output"/><p>That was the velocity. Let&#39;s also plot the friction force acting on the object throughout the simulation.</p><pre><code class="language-julia hljs">scatter(sol_ref.t, friction.(first.(sol_ref.u)), label = &quot;friction force&quot;)</code></pre><img src="94a03335.svg" alt="Example block output"/><h2 id="Model-Setup"><a class="docs-heading-anchor" href="#Model-Setup">Model Setup</a><a id="Model-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Setup" title="Permalink"></a></h2><p>Now, we will try to learn the same friction model using a neural network. We will use <a href="../api/#ModelingToolkitNeuralNets.NeuralNetworkBlock"><code>NeuralNetworkBlock</code></a> to define neural network as a component. The input of the neural network is the velocity and the output is the friction force. We connect the neural network with the model using <code>RealInputArray</code> and <code>RealOutputArray</code> blocks.</p><pre><code class="language-julia hljs">function friction_ude(Fu)
    @variables y(t) = 0.0
    @constants Fu = Fu
    @named nn_in = RealInputArray(nin = 1)
    @named nn_out = RealOutputArray(nout = 1)
    eqs = [Dt(y) ~ Fu - nn_in.u[1]
           y ~ nn_out.u[1]]
    return ODESystem(eqs, t, name = :friction, systems = [nn_in, nn_out])
end

Fu = 120.0
model = friction_ude(Fu)

chain = Lux.Chain(
    Lux.Dense(1 =&gt; 10, Lux.mish, use_bias = false),
    Lux.Dense(10 =&gt; 10, Lux.mish, use_bias = false),
    Lux.Dense(10 =&gt; 1, use_bias = false)
)
@named nn = NeuralNetworkBlock(1, 1; chain = chain, rng = StableRNG(1111))

eqs = [connect(model.nn_in, nn.output)
       connect(model.nn_out, nn.input)]

ude_sys = complete(ODESystem(eqs, t, systems = [model, nn], name = :ude_sys))
sys = structural_simplify(ude_sys)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} friction_{+}y\left( t \right)}{\mathrm{d}t} =&amp; friction_{+}Fu - friction_{+}nn_{in_{+}u(t)_1} \\
0 =&amp;  - friction_{+}nn_{out_{+}u(t)_1} + nn_{+}input_{+}u(t)_1
\end{align}
 \]</p><h2 id="Optimization-Setup"><a class="docs-heading-anchor" href="#Optimization-Setup">Optimization Setup</a><a id="Optimization-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Setup" title="Permalink"></a></h2><p>We now setup the loss function and the optimization loop.</p><pre><code class="language-julia hljs">function loss(x, (prob, sol_ref, get_vars, get_refs))
    new_p = SciMLStructures.replace(Tunable(), prob.p, x)
    new_prob = remake(prob, p = new_p, u0 = eltype(x).(prob.u0))
    ts = sol_ref.t
    new_sol = solve(new_prob, Rodas4(), saveat = ts, abstol = 1e-8, reltol = 1e-8)
    loss = zero(eltype(x))
    for i in eachindex(new_sol.u)
        loss += sum(abs2.(get_vars(new_sol, i) .- get_refs(sol_ref, i)))
    end
    if SciMLBase.successful_retcode(new_sol)
        loss
    else
        Inf
    end
end

of = OptimizationFunction{true}(loss, AutoForwardDiff())

prob = ODEProblem(sys, [], (0, 0.1), [])
get_vars = getu(sys, [sys.friction.y])
get_refs = getu(model_true, [model_true.y])
x0 = reduce(vcat, getindex.((default_values(sys),), tunable_parameters(sys)))

cb = (opt_state, loss) -&gt; begin
    @info &quot;step $(opt_state.iter), loss: $loss&quot;
    return false
end

op = OptimizationProblem(of, x0, (prob, sol_ref, get_vars, get_refs))
res = solve(op, Adam(5e-3); maxiters = 10000, callback = cb)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Default
u: 120-element Vector{Float64}:
 -2.4241656764218797
 -2.39005422132113
  1.1112164465391925
 -1.943486818582218
  0.7485132029344365
 -2.3636694057868866
  0.5180392804622207
 -0.179925767031716
 -2.436048519073904
 -2.433212239040956
  ⋮
 -1.1101060700017755
  0.936074494555787
  0.0854572971259469
 -0.38344554695912914
  1.558922929527129
  1.3488446142669155
 -0.8030339573615891
 -1.1331881064130926
  0.9594061551410016</code></pre><h2 id="Visualization-of-results"><a class="docs-heading-anchor" href="#Visualization-of-results">Visualization of results</a><a id="Visualization-of-results-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-results" title="Permalink"></a></h2><p>We now have a trained neural network! We can check whether running the simulation of the model embedded with the neural network matches the data or not.</p><pre><code class="language-julia hljs">res_p = SciMLStructures.replace(Tunable(), prob.p, res)
res_prob = remake(prob, p = res_p)
res_sol = solve(res_prob, Rodas4(), saveat = sol_ref.t)</code></pre><p>Also, it would be interesting to check the simulation before the training to get an idea of the starting point of the network.</p><pre><code class="language-julia hljs">initial_sol = solve(prob, Rodas4(), saveat = sol_ref.t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 1st order linear
t: 101-element Vector{Float64}:
 0.0
 0.001
 0.002
 0.003
 0.004
 0.005
 0.006
 0.007
 0.008
 0.009
 ⋮
 0.092
 0.093
 0.094
 0.095
 0.096
 0.097
 0.098
 0.099
 0.1
u: 101-element Vector{Vector{Float64}}:
 [0.0, 0.0]
 [0.12001081871231119, 0.12001081871231117]
 [0.24004344032873845, 0.24004344032873853]
 [0.36009816044815607, 0.3600981604481559]
 [0.48017528966709133, 0.4801752896670914]
 [0.6002752784443525, 0.6002752784443525]
 [0.7203984526776133, 0.7203984526776134]
 [0.8405449086211759, 0.8405449086211761]
 [0.9607147425293424, 0.9607147425293425]
 [1.0809079666797878, 1.0809079666797878]
 ⋮
 [11.113594084190066, 11.113594084190066]
 [11.23498410624118, 11.23498410624118]
 [11.35637774264833, 11.35637774264833]
 [11.477782208613382, 11.477782208613382]
 [11.599197527733121, 11.599197527733121]
 [11.720623723604334, 11.720623723604334]
 [11.842060819823802, 11.842060819823802]
 [11.96350883998831, 11.96350883998831]
 [12.084967807694643, 12.084967807694643]</code></pre><p>Now we plot it.</p><pre><code class="language-julia hljs">scatter(sol_ref, idxs = [model_true.y], label = &quot;ground truth velocity&quot;)
plot!(res_sol, idxs = [sys.friction.y], label = &quot;velocity after training&quot;)
plot!(initial_sol, idxs = [sys.friction.y], label = &quot;velocity before training&quot;)</code></pre><img src="0a0f2575.svg" alt="Example block output"/><p>It matches the data well! Let&#39;s also check the predictions for the friction force and whether the network learnt the friction model or not.</p><pre><code class="language-julia hljs">scatter(sol_ref.t, friction.(first.(sol_ref.u)), label = &quot;ground truth friction&quot;)
plot!(res_sol.t, Fu .- first.(res_sol(res_sol.t, Val{1}).u),
    label = &quot;friction from neural network&quot;)</code></pre><img src="f504882f.svg" alt="Example block output"/><p>It learns the friction model well!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 7 May 2024 13:36">Tuesday 7 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
