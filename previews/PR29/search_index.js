var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"NeuralNetworkBlock","category":"page"},{"location":"api/#ModelingToolkitNeuralNets.NeuralNetworkBlock","page":"API","title":"ModelingToolkitNeuralNets.NeuralNetworkBlock","text":"NeuralNetworkBlock(n_input = 1, n_output = 1;\n    chain = multi_layer_feed_forward(n_input, n_output),\n    rng = Xoshiro(0),\n    init_params = Lux.initialparameters(rng, chain),\n    eltype = Float64,\n    name)\n\nCreate an ODESystem with a neural network inside.\n\n\n\n\n\n","category":"function"},{"location":"friction/#Modeling-Non-Linear-Friction-Model-using-UDEs","page":"Friction Model","title":"Modeling Non Linear Friction Model using UDEs","text":"","category":"section"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Friction between moving bodies is not trivial to model. There have been idealised linear models which are not always useful in complicated systems. There have been many theories and non linear models which we can use, but they are not perfect. The aim of this tutorial to use Universal Differential Equations to showcase how we can embed a neural network to learn an unknown non linear friction model.","category":"page"},{"location":"friction/#Julia-Environment","page":"Friction Model","title":"Julia Environment","text":"","category":"section"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"First, lets import the required packages.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"using ModelingToolkitNeuralNets\nusing ModelingToolkit\nimport ModelingToolkit.t_nounits as t\nimport ModelingToolkit.D_nounits as Dt\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEq\nusing Optimization\nusing OptimizationOptimisers: Adam\nusing SciMLStructures\nusing SciMLStructures: Tunable\nusing SymbolicIndexingInterface\nusing StableRNGs\nusing Lux\nusing Plots\nusing Test #hide","category":"page"},{"location":"friction/#Problem-Setup","page":"Friction Model","title":"Problem Setup","text":"","category":"section"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Let's use the friction model presented in https://www.mathworks.com/help/simscape/ref/translationalfriction.html for generating data.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Fbrk = 100.0\nvbrk = 10.0\nFc = 80.0\nvst = vbrk / 10\nvcol = vbrk * sqrt(2)\nfunction friction(v)\n    sqrt(2 * MathConstants.e) * (Fbrk - Fc) * exp(-(v / vst)^2) * (v / vst) +\n    Fc * tanh(v / vcol)\nend","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Next, we define the model - an object sliding in 1D plane with a constant force Fu acting on it and friction force opposing the motion.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"function friction_true()\n    @variables y(t) = 0.0\n    @constants Fu = 120.0\n    eqs = [\n        Dt(y) ~ Fu - friction(y)\n    ]\n    return ODESystem(eqs, t, name = :friction_true)\nend","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Now that we have defined the model, we will simulate it from 0 to 0.1 seconds.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"model_true = structural_simplify(friction_true())\nprob_true = ODEProblem(model_true, [], (0, 0.1), [])\nsol_ref = solve(prob_true, Rodas4(); saveat = 0.001)","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Let's plot it.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"scatter(sol_ref, label = \"velocity\")","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"That was the velocity. Let's also plot the friction force acting on the object throughout the simulation.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"scatter(sol_ref.t, friction.(first.(sol_ref.u)), label = \"friction force\")","category":"page"},{"location":"friction/#Model-Setup","page":"Friction Model","title":"Model Setup","text":"","category":"section"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Now, we will try to learn the same friction model using a neural network. We will use NeuralNetworkBlock to define neural network as a component. The input of the neural network is the velocity and the output is the friction force. We connect the neural network with the model using RealInputArray and RealOutputArray blocks.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"function friction_ude(Fu)\n    @variables y(t) = 0.0\n    @constants Fu = Fu\n    @named nn_in = RealInputArray(nin = 1)\n    @named nn_out = RealOutputArray(nout = 1)\n    eqs = [Dt(y) ~ Fu - nn_in.u[1]\n           y ~ nn_out.u[1]]\n    return ODESystem(eqs, t, name = :friction, systems = [nn_in, nn_out])\nend\n\nFu = 120.0\nmodel = friction_ude(Fu)\n\nchain = Lux.Chain(\n    Lux.Dense(1 => 10, Lux.mish, use_bias = false),\n    Lux.Dense(10 => 10, Lux.mish, use_bias = false),\n    Lux.Dense(10 => 1, use_bias = false)\n)\n@named nn = NeuralNetworkBlock(1, 1; chain = chain, rng = StableRNG(1111))\n\neqs = [connect(model.nn_in, nn.output)\n       connect(model.nn_out, nn.input)]\n\nude_sys = complete(ODESystem(eqs, t, systems = [model, nn], name = :ude_sys))\nsys = structural_simplify(ude_sys)","category":"page"},{"location":"friction/#Optimization-Setup","page":"Friction Model","title":"Optimization Setup","text":"","category":"section"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"We now setup the loss function and the optimization loop.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"function loss(x, (prob, sol_ref, get_vars, get_refs))\n    new_p = SciMLStructures.replace(Tunable(), prob.p, x)\n    new_prob = remake(prob, p = new_p, u0 = eltype(x).(prob.u0))\n    ts = sol_ref.t\n    new_sol = solve(new_prob, Rodas4(), saveat = ts, abstol = 1e-8, reltol = 1e-8)\n    loss = zero(eltype(x))\n    for i in eachindex(new_sol.u)\n        loss += sum(abs2.(get_vars(new_sol, i) .- get_refs(sol_ref, i)))\n    end\n    if SciMLBase.successful_retcode(new_sol)\n        loss\n    else\n        Inf\n    end\nend\n\nof = OptimizationFunction{true}(loss, AutoForwardDiff())\n\nprob = ODEProblem(sys, [], (0, 0.1), [])\nget_vars = getu(sys, [sys.friction.y])\nget_refs = getu(model_true, [model_true.y])\nx0 = reduce(vcat, getindex.((default_values(sys),), tunable_parameters(sys)))\n\ncb = (opt_state, loss) -> begin\n    @info \"step $(opt_state.iter), loss: $loss\"\n    return false\nend\n\nop = OptimizationProblem(of, x0, (prob, sol_ref, get_vars, get_refs))\nres = solve(op, Adam(5e-3); maxiters = 10000, callback = cb)","category":"page"},{"location":"friction/#Visualization-of-results","page":"Friction Model","title":"Visualization of results","text":"","category":"section"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"We now have a trained neural network! We can check whether running the simulation of the model embedded with the neural network matches the data or not.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"res_p = SciMLStructures.replace(Tunable(), prob.p, res)\nres_prob = remake(prob, p = res_p)\nres_sol = solve(res_prob, Rodas4(), saveat = sol_ref.t)\n@test first.(sol_ref.u)≈first.(res_sol.u) rtol=1e-3 #hide\n@test friction.(first.(sol_ref.u))≈(Fu .- first.(res_sol(res_sol.t, Val{1}).u)) rtol=1e-1 #hide\nnothing #hide","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Also, it would be interesting to check the simulation before the training to get an idea of the starting point of the network.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"initial_sol = solve(prob, Rodas4(), saveat = sol_ref.t)","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"Now we plot it.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"scatter(sol_ref, idxs = [model_true.y], label = \"ground truth velocity\")\nplot!(res_sol, idxs = [sys.friction.y], label = \"velocity after training\")\nplot!(initial_sol, idxs = [sys.friction.y], label = \"velocity before training\")","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"It matches the data well! Let's also check the predictions for the friction force and whether the network learnt the friction model or not.","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"scatter(sol_ref.t, friction.(first.(sol_ref.u)), label = \"ground truth friction\")\nplot!(res_sol.t, Fu .- first.(res_sol(res_sol.t, Val{1}).u),\n    label = \"friction from neural network\")","category":"page"},{"location":"friction/","page":"Friction Model","title":"Friction Model","text":"It learns the friction model well!","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ModelingToolkitNeuralNets","category":"page"},{"location":"#ModelingToolkitNeuralNets.jl","page":"Home","title":"ModelingToolkitNeuralNets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkitNeuralNets.jl is a package to create neural network components defined similar to MTKStandardLibrary components, to use them for solving Universal Differential Equations. It can be plugged to any part of the equations in an ODESystem using RealInputArray and RealOutputArray components which gives a lot of flexibility to add missing physics only to the relevant parts of the model.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install ModelingToolkitNeuralNets.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModelingToolkitNeuralNets\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
